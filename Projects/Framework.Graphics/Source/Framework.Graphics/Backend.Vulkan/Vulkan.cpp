#include "Vulkan.h"

namespace W
{
	const char* VK::TraslateResult(VkResult result)
	{
		switch (result)
		{
#define RESULT_STR(v) case VK_ ##v: return #v
			RESULT_STR(SUCCESS);
			RESULT_STR(NOT_READY);
			RESULT_STR(TIMEOUT);
			RESULT_STR(EVENT_SET);
			RESULT_STR(EVENT_RESET);
			RESULT_STR(INCOMPLETE);
			RESULT_STR(ERROR_OUT_OF_HOST_MEMORY);
			RESULT_STR(ERROR_OUT_OF_DEVICE_MEMORY);
			RESULT_STR(ERROR_INITIALIZATION_FAILED);
			RESULT_STR(ERROR_DEVICE_LOST);
			RESULT_STR(ERROR_MEMORY_MAP_FAILED);
			RESULT_STR(ERROR_LAYER_NOT_PRESENT);
			RESULT_STR(ERROR_EXTENSION_NOT_PRESENT);
			RESULT_STR(ERROR_FEATURE_NOT_PRESENT);
			RESULT_STR(ERROR_INCOMPATIBLE_DRIVER);
			RESULT_STR(ERROR_TOO_MANY_OBJECTS);
			RESULT_STR(ERROR_FORMAT_NOT_SUPPORTED);
			RESULT_STR(ERROR_FRAGMENTED_POOL);
			RESULT_STR(ERROR_UNKNOWN);
			RESULT_STR(ERROR_OUT_OF_POOL_MEMORY);
			RESULT_STR(ERROR_INVALID_EXTERNAL_HANDLE);
			RESULT_STR(ERROR_FRAGMENTATION);
			RESULT_STR(ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS);
			RESULT_STR(ERROR_SURFACE_LOST_KHR);
			RESULT_STR(ERROR_NATIVE_WINDOW_IN_USE_KHR);
			RESULT_STR(SUBOPTIMAL_KHR);
			RESULT_STR(ERROR_OUT_OF_DATE_KHR);
			RESULT_STR(ERROR_INCOMPATIBLE_DISPLAY_KHR);
			RESULT_STR(ERROR_VALIDATION_FAILED_EXT);
			RESULT_STR(ERROR_INVALID_SHADER_NV);
			RESULT_STR(ERROR_INCOMPATIBLE_VERSION_KHR);
			RESULT_STR(ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT);
			RESULT_STR(ERROR_NOT_PERMITTED_EXT);
			RESULT_STR(ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT);
			RESULT_STR(THREAD_IDLE_KHR);
			RESULT_STR(THREAD_DONE_KHR);
			RESULT_STR(OPERATION_DEFERRED_KHR);
			RESULT_STR(OPERATION_NOT_DEFERRED_KHR);
			RESULT_STR(PIPELINE_COMPILE_REQUIRED_EXT);
			RESULT_STR(RESULT_MAX_ENUM);
#undef RESULT_STR
		default:
			return "UNKNOWN_RESULT_CODE";
		}
	};

	VkResult VK::GetSupportedDepthFormat(VkPhysicalDevice physicalDevice, VkFormat& outDepthFormat)
	{
		// Since all depth formats may be optional, we need to find a suitable depth format to use
		// ordered by priority
		VkFormat depthFormats[] = 
		{
			VK_FORMAT_D32_SFLOAT_S8_UINT,
			VK_FORMAT_D32_SFLOAT,
			VK_FORMAT_D24_UNORM_S8_UINT,
			VK_FORMAT_D16_UNORM_S8_UINT,
			VK_FORMAT_D16_UNORM
		};

		for (VkFormat& format : depthFormats)
		{
			VkFormatProperties formatProps;
			vkGetPhysicalDeviceFormatProperties(physicalDevice, format, &formatProps);

			// Format must support depth stencil attachment for optimal tiling
			if (formatProps.optimalTilingFeatures & VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT)
			{
				outDepthFormat = format;
				return VK_SUCCESS;
			}
		}

		outDepthFormat = VK_FORMAT_UNDEFINED;
		return VK_ERROR_FORMAT_NOT_SUPPORTED;
	}
} // namespace W